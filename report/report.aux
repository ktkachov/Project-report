\relax 
\ifx\hyper@anchor\@undefined
\global \let \oldcontentsline\contentsline
\gdef \contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global \let \oldnewlabel\newlabel
\gdef \newlabel#1#2{\newlabelxx{#1}#2}
\gdef \newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\let \contentsline\oldcontentsline
\let \newlabel\oldnewlabel}
\else
\global \let \hyper@last\relax 
\fi

\@writefile{toc}{\contentsline {chapter}{\numberline {1}Introduction}{4}{chapter.1}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}The domain}{4}{section.1.1}}
\@writefile{toc}{\contentsline {section}{\numberline {1.2}The Airfoil program}{5}{section.1.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.1}{\ignorespaces Example Airfoil mesh}}{5}{figure.caption.3}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{fig:airfoil_mesh}{{1.1}{5}{Example Airfoil mesh\relax }{figure.caption.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {1.3}FPGAs, streaming and acceleration}{6}{section.1.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {1.2}{\ignorespaces Simple dataflow graph}}{7}{figure.caption.4}}
\newlabel{fig:graph_simple}{{1.2}{7}{Simple dataflow graph\relax }{figure.caption.4}{}}
\@writefile{toc}{\contentsline {section}{\numberline {1.4}Contributions}{7}{section.1.4}}
\@writefile{toc}{\contentsline {chapter}{\numberline {2}Background}{8}{chapter.2}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {2.1}Unstructured meshes and their representation}{8}{section.2.1}}
\citation{OP2_presentation}
\@writefile{lof}{\contentsline {figure}{\numberline {2.1}{\ignorespaces Mesh representation with indirection arrays}}{9}{figure.caption.5}}
\newlabel{fig:mesh_small_example}{{2.1}{9}{Mesh representation with indirection arrays\relax }{figure.caption.5}{}}
\citation{OP2_presentation}
\@writefile{lof}{\contentsline {figure}{\numberline {2.2}{\ignorespaces Mesh data set example}}{10}{figure.caption.6}}
\newlabel{fig:data_set_ex}{{2.2}{10}{Mesh data set example\relax }{figure.caption.6}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2.2}Airfoil}{10}{section.2.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.3}{\ignorespaces Example mesh coloring}}{11}{figure.caption.7}}
\newlabel{fig:mesh_coloured}{{2.3}{11}{Example mesh coloring\relax }{figure.caption.7}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.1}Computational kernels and data sets}{12}{subsection.2.2.1}}
\@writefile{lot}{\contentsline {table}{\numberline {2.1}{\ignorespaces Table showing the data sets and their types. In the actual implementation, we may choose to represent real numbers ($\mathbb  {R}$) as standard or double precision floating point numbers or as fixed point numbers (discussed later). Elements of dimension larger than one will be represented as arrays. The physical meaning of these sets is not important, however Airfoil is generally intereseted in computing a steady-state solution for the q data set.\relax }}{12}{table.caption.8}}
\newlabel{tab:Airfoil_datasets}{{2.1}{12}{Table showing the data sets and their types. In the actual implementation, we may choose to represent real numbers ($\mathbb {R}$) as standard or double precision floating point numbers or as fixed point numbers (discussed later). Elements of dimension larger than one will be represented as arrays. The physical meaning of these sets is not important, however Airfoil is generally intereseted in computing a steady-state solution for the q data set.\relax \relax }{table.caption.8}{}}
\@writefile{lot}{\contentsline {table}{\numberline {2.2}{\ignorespaces Table showing the kernels defined in airfoil and their data requirements.\relax }}{12}{table.caption.9}}
\newlabel{tab:Airfoil_kernels}{{2.2}{12}{Table showing the kernels defined in airfoil and their data requirements.\relax \relax }{table.caption.9}{}}
\@writefile{lol}{\contentsline {listing}{\numberline {1}{\ignorespaces  Definition of the res\_calc kernel with reals represented as single precision floating point numbers. Note the type signature. The kernel requires the element of the dataset x associated with each of the two nodes of the edge we are currently processing and the q, adt and res elements of the two cells associted with the current edge. Note that the res set is updated by incrementing (+=), introducing dependencies between parallel applications of the kernel to different edges. The important part of this definition are the data requirements of the kernel and not the exact meaning of the arithmetic operations. The variables $gm1$ and $eps$ are global constants that do not need to be passed in explicitly. \relax }}{13}{listing.1}}
\newlabel{lst:ResCalcKernelC}{{1}{13}{ Definition of the res\_calc kernel with reals represented as single precision floating point numbers. Note the type signature. The kernel requires the element of the dataset x associated with each of the two nodes of the edge we are currently processing and the q, adt and res elements of the two cells associted with the current edge. Note that the res set is updated by incrementing (+=), introducing dependencies between parallel applications of the kernel to different edges. The important part of this definition are the data requirements of the kernel and not the exact meaning of the arithmetic operations. The variables $gm1$ and $eps$ are global constants that do not need to be passed in explicitly.\label {lst:ResCalcKernelC} \relax \relax }{listing.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.2}Indirection maps}{13}{subsection.2.2.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.4}{\ignorespaces Airfoil maps relationships}}{14}{figure.caption.10}}
\newlabel{fig:Airfoil_maps}{{2.4}{14}{Airfoil maps relationships\relax }{figure.caption.10}{}}
\@writefile{lot}{\contentsline {table}{\numberline {2.3}{\ignorespaces Table showing the time spent in each kernel during a run of a single-threaded sequential version of Airfoil on a current CPU. The total run time is 115.6 seconds.\relax }}{15}{table.caption.11}}
\newlabel{tab:Airfoil_timesCPU}{{2.3}{15}{Table showing the time spent in each kernel during a run of a single-threaded sequential version of Airfoil on a current CPU. The total run time is 115.6 seconds.\relax \relax }{table.caption.11}{}}
\citation{Virtex6Spec}
\citation{MaxCompiler_whitepaper}
\citation{XilinxISE}
\@writefile{lol}{\contentsline {listing}{\numberline {2}{\ignorespaces  The iteration structure of Airfoil.  \relax }}{16}{listing.2}}
\newlabel{lst:AirfoilIteration}{{2}{16}{ The iteration structure of Airfoil. \label {lst:AirfoilIteration} \relax \relax }{listing.2}{}}
\citation{MaxCompiler_whitepaper}
\@writefile{toc}{\contentsline {section}{\numberline {2.3}Hardware platform, Maxeler toolchain and the streaming model of computation}{17}{section.2.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.5}{\ignorespaces Maxeler toolchain diagram}}{17}{figure.caption.12}}
\newlabel{fig:max_toolchain}{{2.5}{17}{Maxeler toolchain diagram\relax }{figure.caption.12}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.1}MaxCompiler example}{18}{subsection.2.3.1}}
\@writefile{lol}{\contentsline {listing}{\numberline {3}{\ignorespaces  A MaxCompiler definition of a kernel that computes a moving 3-point average with boundary conditions. Note that the arithmetic operators as well as the ternary if operator have been overloaded for HWVar objects that represent the value of a hardware stream.  \relax }}{18}{listing.3}}
\newlabel{lst:MaxCompilerMovAvg}{{3}{18}{ A MaxCompiler definition of a kernel that computes a moving 3-point average with boundary conditions. Note that the arithmetic operators as well as the ternary if operator have been overloaded for HWVar objects that represent the value of a hardware stream. \label {lst:MaxCompilerMovAvg} \relax \relax }{listing.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.6}{\ignorespaces Example data flow graph for MaxCompiler example}}{19}{figure.caption.13}}
\newlabel{fig:MovAvgGraph}{{2.6}{19}{Example data flow graph for MaxCompiler example\relax }{figure.caption.13}{}}
\@writefile{lol}{\contentsline {listing}{\numberline {4}{\ignorespaces  Manager specification for a MovingAverageKernel that streams the input data "x" from the host and streams the output data "y" to the host. The $<==$ operator means connect the right hand side stream to the left hand side stream. The code instantiates the MovingAverageKernel, creates a stream called "x" from the host and connects it to the input stream "x" in the kernel. Then it creates a stream to the host called "y" and connects to it the output stream "y" from the kernel.  \relax }}{20}{listing.4}}
\newlabel{lst:MaxCompilerMovAvgManager}{{4}{20}{ Manager specification for a MovingAverageKernel that streams the input data "x" from the host and streams the output data "y" to the host. The $<==$ operator means connect the right hand side stream to the left hand side stream. The code instantiates the MovingAverageKernel, creates a stream called "x" from the host and connects it to the input stream "x" in the kernel. Then it creates a stream to the host called "y" and connects to it the output stream "y" from the kernel. \label {lst:MaxCompilerMovAvgManager} \relax \relax }{listing.4}{}}
\citation{Virtex6Spec}
\@writefile{lol}{\contentsline {listing}{\numberline {5}{\ignorespaces  A sample host code using the MaxCompilerRT API for the C language.  \relax }}{22}{listing.5}}
\newlabel{lst:MovAvgHostCode}{{5}{22}{ A sample host code using the MaxCompilerRT API for the C language. \label {lst:MovAvgHostCode} \relax \relax }{listing.5}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.2}Hardware}{23}{subsection.2.3.2}}
\citation{METISPaper}
\@writefile{lof}{\contentsline {figure}{\numberline {2.7}{\ignorespaces MAX3 card components}}{24}{figure.caption.14}}
\newlabel{fig:maxHW}{{2.7}{24}{MAX3 card components\relax }{figure.caption.14}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.3}Mesh partitioning and halos}{24}{subsection.2.3.3}}
\citation{IEEEFP}
\citation{IEEEFP}
\@writefile{lof}{\contentsline {figure}{\numberline {2.8}{\ignorespaces Mesh partitioning and halos}}{25}{figure.caption.15}}
\newlabel{fig:partition}{{2.8}{25}{Mesh partitioning and halos\relax }{figure.caption.15}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.4}Floating point vs fixed point arithmetic}{25}{subsection.2.3.4}}
\citation{OP2_presentation}
\citation{OP2_Cluster}
\citation{OP2_presentation}
\@writefile{lof}{\contentsline {figure}{\numberline {2.9}{\ignorespaces IEEE-754 floating point representation}}{26}{figure.caption.16}}
\newlabel{fig:FPSP}{{2.9}{26}{IEEE-754 floating point representation\relax }{figure.caption.16}{}}
\@writefile{toc}{\contentsline {section}{\numberline {2.4}Previous work}{26}{section.2.4}}
\citation{UnstructuredMeshCCM}
\citation{MemoryHierarchy}
\citation{SpanishFPGAAirfoil}
\citation{SpanishFPGAAirfoil2}
\citation{SpanishFPGAAirfoil}
\citation{ElectromagneticsFPGA}
\citation{Biology}
\citation{GPUModel}
\citation{GPUGhost}
\citation{MeshIntensityROSE}
\citation{MeshCache}
\citation{WLuk}
\citation{MemoryHierarchy}
\citation{WLuk}
\@writefile{toc}{\contentsline {chapter}{\numberline {3}Design and Modelling}{31}{chapter.3}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {3.1}DRAM and mesh storage}{31}{section.3.1}}
\@writefile{toc}{\contentsline {section}{\numberline {3.2}Result accumulation and storage}{32}{section.3.2}}
\citation{GhostCellPaper}
\@writefile{lof}{\contentsline {figure}{\numberline {3.1}{\ignorespaces Initial accelerator architecture diagram}}{33}{figure.caption.17}}
\newlabel{fig:Architecture1st}{{3.1}{33}{Initial accelerator architecture diagram\relax }{figure.caption.17}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3.3}Halo exchange mechanism}{33}{section.3.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.2}{\ignorespaces Accelerator architecture diagram with halo exchange}}{35}{figure.caption.18}}
\newlabel{fig:ArchitecturePCIe}{{3.2}{35}{Accelerator architecture diagram with halo exchange\relax }{figure.caption.18}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3.4}Two-level partitioning}{36}{section.3.4}}
\newlabel{sec:two_part}{{3.4}{36}{Two-level partitioning\relax }{section.3.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.3}{\ignorespaces Two-level partitioning}}{37}{figure.caption.19}}
\newlabel{fig:upartition}{{3.3}{37}{Two-level partitioning\relax }{figure.caption.19}{}}
\citation{Pipeline}
\@writefile{lof}{\contentsline {figure}{\numberline {3.4}{\ignorespaces Architecture diagram with state machine added}}{38}{figure.caption.20}}
\newlabel{fig:ArchitectureSM}{{3.4}{38}{Architecture diagram with state machine added\relax }{figure.caption.20}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3.5}The case for a custom streaming pipeline}{38}{section.3.5}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.5}{\ignorespaces Overlapping of execution and I/O on the FPGA}}{39}{figure.caption.21}}
\newlabel{fig:partPipeline}{{3.5}{39}{Overlapping of execution and I/O on the FPGA\relax }{figure.caption.21}{}}
\citation{SpanishFPGAAirfoil}
\@writefile{lof}{\contentsline {figure}{\numberline {3.6}{\ignorespaces Custom pipeline vs conventional CPU}}{43}{figure.caption.22}}
\newlabel{fig:StreamVsCPU}{{3.6}{43}{Custom pipeline vs conventional CPU\relax }{figure.caption.22}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3.6}Performance Model}{43}{section.3.6}}
\newlabel{sec:perf_model}{{3.6}{43}{Performance Model\relax }{section.3.6}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.1}Phase 1}{44}{subsection.3.6.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.2}Phase 2}{45}{subsection.3.6.2}}
\citation{TeslaM2050}
\citation{OpenCL}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.3}Phase 3}{46}{subsection.3.6.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.4}Design space exploration}{46}{subsection.3.6.4}}
\@writefile{lot}{\contentsline {table}{\numberline {3.1}{\ignorespaces Table showing the time spent in each kernel during a run of a hardware accelerated version of Airfoil on a Tesla M2050 GPU. The total run time is 9.67 seconds for 2000 iterations. The corresponding times of the serial single-threaded implementation as shown in Table \ref  {tab:Airfoil_timesCPU} are shown here. The GPU implementation is programmed using the OpenCL backend of OP2.\relax }}{47}{table.caption.23}}
\newlabel{tab:Airfoil_timesCPU}{{3.1}{47}{Table showing the time spent in each kernel during a run of a hardware accelerated version of Airfoil on a Tesla M2050 GPU. The total run time is 9.67 seconds for 2000 iterations. The corresponding times of the serial single-threaded implementation as shown in Table \ref {tab:Airfoil_timesCPU} are shown here. The GPU implementation is programmed using the OpenCL backend of OP2.\relax \relax }{table.caption.23}{}}
\@writefile{toc}{\contentsline {subsubsection}{Number of arithmetic pipelines $n_p$}{47}{section*.24}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.7}{\ignorespaces Execution time against number of pipelines}}{48}{figure.caption.25}}
\newlabel{fig:Pipelines}{{3.7}{48}{Execution time against number of pipelines\relax }{figure.caption.25}{}}
\@writefile{toc}{\contentsline {subsubsection}{Clock frequency $f$}{48}{section*.26}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.8}{\ignorespaces Execution time against clock frequency}}{49}{figure.caption.27}}
\newlabel{fig:frequencies}{{3.8}{49}{Execution time against clock frequency\relax }{figure.caption.27}{}}
\@writefile{toc}{\contentsline {subsubsection}{Clock frequency $f$ and arithmetic pipelines $n_p$}{49}{section*.28}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.9}{\ignorespaces Execution time against number of pipelines and frequency}}{50}{figure.caption.29}}
\newlabel{fig:frequencies_pipelines}{{3.9}{50}{Execution time against number of pipelines and frequency\relax }{figure.caption.29}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.10}{\ignorespaces 3-D plot of execution time against number of pipelines and frequency}}{50}{figure.caption.30}}
\newlabel{fig:frequencies_pipelines3D}{{3.10}{50}{3-D plot of execution time against number of pipelines and frequency\relax }{figure.caption.30}{}}
\@writefile{toc}{\contentsline {subsubsection}{Partition size $C_{pp}$}{51}{section*.31}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.11}{\ignorespaces Execution time against partition size}}{51}{figure.caption.32}}
\newlabel{fig:partition_sizes}{{3.11}{51}{Execution time against partition size\relax }{figure.caption.32}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.12}{\ignorespaces DRAM to PCIe transfer time ratio}}{52}{figure.caption.33}}
\newlabel{fig:partition_ratios}{{3.12}{52}{DRAM to PCIe transfer time ratio\relax }{figure.caption.33}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3.7}Conclusion}{53}{section.3.7}}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}Implementation}{54}{chapter.4}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}Mesh partitioning}{54}{section.4.1}}
\@writefile{toc}{\contentsline {section}{\numberline {4.2}Edge scheduling}{55}{section.4.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.1}{\ignorespaces Accumulation part with edge dependencies}}{56}{figure.caption.34}}
\newlabel{fig:edge_dependency}{{4.1}{56}{Accumulation part with edge dependencies\relax }{figure.caption.34}{}}
\@writefile{prog}{\contentsline {program}{\numberline {1}{\ignorespaces Pseudocode that validates an edge schedule $sch$ of $n$ edges with window width $l$.\relax }}{56}{program.1}}
\newlabel{alg:valid_schedule}{{1}{56}{Pseudocode that validates an edge schedule $sch$ of $n$ edges with window width $l$.\relax \relax }{program.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.2}{\ignorespaces Edge partitions and adjacency graph}}{57}{figure.caption.35}}
\newlabel{fig:parts_graph}{{4.2}{57}{Edge partitions and adjacency graph\relax }{figure.caption.35}{}}
\@writefile{prog}{\contentsline {program}{\numberline {2}{\ignorespaces Pseudocode that validates a node schedule $sch$ of an adjacency graph $g$ with $n$ elements for a window width of $l$.\relax }}{57}{program.2}}
\newlabel{alg:valid_schedule_graph}{{2}{57}{Pseudocode that validates a node schedule $sch$ of an adjacency graph $g$ with $n$ elements for a window width of $l$.\relax \relax }{program.2}{}}
\@writefile{prog}{\contentsline {program}{\numberline {3}{\ignorespaces Pseudocode that computes a schedule for the nodes in a graph $g$ with window width $l$.\relax }}{59}{program.3}}
\newlabel{alg:schedule_algorithm}{{3}{59}{Pseudocode that computes a schedule for the nodes in a graph $g$ with window width $l$.\relax \relax }{program.3}{}}
\@writefile{prog}{\contentsline {program}{\numberline {4}{\ignorespaces Pseudocode that checks whether inserting node $n$ at position $c$ into the schedule $arr$ will produce a valid partial schedule for window width $l$ of the nodes in graph $g$.\relax }}{60}{program.4}}
\newlabel{alg:schedule_validPos}{{4}{60}{Pseudocode that checks whether inserting node $n$ at position $c$ into the schedule $arr$ will produce a valid partial schedule for window width $l$ of the nodes in graph $g$.\relax \relax }{program.4}{}}
\citation{HamiltonianPath}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.1}No-op edges}{61}{subsection.4.2.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.2}Complexity}{61}{subsection.4.2.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.3}{\ignorespaces Graph schedule to edge schedule}}{62}{figure.caption.36}}
\newlabel{fig:edge_sched_order}{{4.3}{62}{Graph schedule to edge schedule\relax }{figure.caption.36}{}}
\citation{GraphColouring}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.3}No-op edge-partitions}{63}{subsection.4.2.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.4}Graph colouring and edge scheduling revisited}{63}{subsection.4.2.4}}
\newlabel{sec:colouring}{{4.2.4}{63}{Graph colouring and edge scheduling revisited\relax }{subsection.4.2.4}{}}
\@writefile{prog}{\contentsline {program}{\numberline {5}{\ignorespaces A greedy colouring algorithm that takes an undirected graph $g$ and returns an array containing the colour of each node in $g$\relax }}{65}{program.5}}
\newlabel{alg:colouring}{{5}{65}{A greedy colouring algorithm that takes an undirected graph $g$ and returns an array containing the colour of each node in $g$\relax \relax }{program.5}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.3}Data sets and padding}{66}{section.4.3}}
\@writefile{lot}{\contentsline {table}{\numberline {4.1}{\ignorespaces Table showing the amount of padding added to each dataset to enable streaming.\relax }}{67}{table.caption.37}}
\newlabel{tab:data_padding}{{4.1}{67}{Table showing the amount of padding added to each dataset to enable streaming.\relax \relax }{table.caption.37}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4.4}Data layout and preparation for streaming}{67}{section.4.4}}
\@writefile{toc}{\contentsline {section}{\numberline {4.5}FPGA accelerator}{68}{section.4.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5.1}I/O streams and manager}{68}{subsection.4.5.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.4}{\ignorespaces Manager graph of the FPGA}}{69}{figure.caption.38}}
\newlabel{fig:ManagerGraph}{{4.4}{69}{Manager graph of the FPGA\relax }{figure.caption.38}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5.2}Result RAM division and duplication}{69}{subsection.4.5.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.5}{\ignorespaces Division of result RAMs}}{71}{figure.caption.39}}
\newlabel{fig:ram_division}{{4.5}{71}{Division of result RAMs\relax }{figure.caption.39}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5.3}Resource usage}{72}{subsection.4.5.3}}
\@writefile{lot}{\contentsline {table}{\numberline {4.2}{\ignorespaces Table showing the resource usage of our implementation\relax }}{72}{table.caption.40}}
\newlabel{tab:resource_usage}{{4.2}{72}{Table showing the resource usage of our implementation\relax \relax }{table.caption.40}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5.4}State machine}{72}{subsection.4.5.4}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.6}{\ignorespaces Hardware counter example}}{73}{figure.caption.41}}
\newlabel{fig:hw_counter}{{4.6}{73}{Hardware counter example\relax }{figure.caption.41}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5.5}Validation and hardware build}{73}{subsection.4.5.5}}
\@writefile{toc}{\contentsline {chapter}{\numberline {5}Evaluation}{75}{chapter.5}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {5.1}No-op edges}{75}{section.5.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.1}{\ignorespaces No-op edges to edges ratio against number of edge-partitions}}{76}{figure.caption.42}}
\newlabel{fig:nop_edge_ratio}{{5.1}{76}{No-op edges to edges ratio against number of edge-partitions\relax }{figure.caption.42}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.2}{\ignorespaces Partitioning time agains number of edge-partitions}}{77}{figure.caption.43}}
\newlabel{fig:part_time}{{5.2}{77}{Partitioning time agains number of edge-partitions\relax }{figure.caption.43}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.3}{\ignorespaces Predicted execution time against number of edge-partitions}}{78}{figure.caption.44}}
\newlabel{fig:nop_edge_model}{{5.3}{78}{Predicted execution time against number of edge-partitions\relax }{figure.caption.44}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.2}Performance model validation}{79}{section.5.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.4}{\ignorespaces Measured execution time against number of edge-partitions}}{80}{figure.caption.45}}
\newlabel{fig:nop_edge_modelvsreal}{{5.4}{80}{Measured execution time against number of edge-partitions\relax }{figure.caption.45}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.5}{\ignorespaces Measured and predicted execution times against number of edge-partitions for 100, 120, 140, 160 and 180MHz}}{81}{figure.caption.46}}
\newlabel{fig:100_120MHz}{{5.5}{81}{Measured and predicted execution times against number of edge-partitions for 100, 120, 140, 160 and 180MHz\relax }{figure.caption.46}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.3}Host-side halo reduction}{81}{section.5.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.6}{\ignorespaces FPGA time and halo reduction time for 180MHz}}{82}{figure.caption.47}}
\newlabel{fig:180_whost}{{5.6}{82}{FPGA time and halo reduction time for 180MHz\relax }{figure.caption.47}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.4}Resource usage}{82}{section.5.4}}
\@writefile{lot}{\contentsline {table}{\numberline {5.1}{\ignorespaces Table showing the resource usage of our implementation\relax }}{83}{table.caption.48}}
\newlabel{tab:resource_usage_arith}{{5.1}{83}{Table showing the resource usage of our implementation\relax \relax }{table.caption.48}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.5}Conclusion}{83}{section.5.5}}
\@writefile{toc}{\contentsline {chapter}{\numberline {6}Conclusions and further work}{84}{chapter.6}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {6.1}Contributions and reflection}{84}{section.6.1}}
\@writefile{toc}{\contentsline {section}{\numberline {6.2}Further work}{86}{section.6.2}}
\citation{ParMETIS}
\bibcite{OP2_presentation}{1}
\bibcite{OP2_Cluster}{2}
\bibcite{XilinxISE}{3}
\bibcite{Virtex6Spec}{4}
\bibcite{MaxCompiler_whitepaper}{5}
\bibcite{METISPaper}{6}
\bibcite{IEEEFP}{7}
\bibcite{GhostCellPaper}{8}
\bibcite{UnstructuredMeshCCM}{9}
\@writefile{toc}{\contentsline {chapter}{Bibliography}{88}{chapter*.49}}
\bibcite{MemoryHierarchy}{10}
\bibcite{SpanishFPGAAirfoil}{11}
\bibcite{SpanishFPGAAirfoil2}{12}
\bibcite{ElectromagneticsFPGA}{13}
\bibcite{WLuk}{14}
\bibcite{Biology}{15}
\bibcite{GPUModel}{16}
\bibcite{GPUGhost}{17}
\bibcite{MeshIntensityROSE}{18}
\bibcite{MeshCache}{19}
\bibcite{floatFPGA}{20}
\bibcite{Pipeline}{21}
\bibcite{OpenCL}{22}
\bibcite{TeslaM2050}{23}
\bibcite{HamiltonianPath}{24}
\bibcite{GraphColouring}{25}
\bibcite{ParMETIS}{26}
\@writefile{toc}{\contentsline {chapter}{\numberline {A}Code Samples}{91}{appendix.A}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {A.1}Airfoil Kernel definitions in C}{91}{section.A.1}}
\newlabel{app_kernels}{{A.1}{91}{Airfoil Kernel definitions in C\relax }{section.A.1}{}}
\@writefile{toc}{\contentsline {chapter}{List of Figures}{95}{appendix*.50}}
